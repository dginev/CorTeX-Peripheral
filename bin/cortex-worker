#!/usr/bin/perl
# /=====================================================================\ #
# |  CorTeX Framework                                                   | #
# | A Generic Worker for Gearman                                        | #
# |=====================================================================| #
# | Part of the LaMaPUn project: https://trac.kwarc.info/lamapun/       | #
# |  Research software, produced as part of work done by:               | #
# |  the KWARC group at Jacobs University                               | #
# | Copyright (c) 2012                                                  | #
# | Released under the GNU Public License                               | #
# |---------------------------------------------------------------------| #
# | Deyan Ginev <d.ginev@jacobs-university.de>                  #_#     | #
# | http://kwarc.info/people/dginev                            (o o)    | #
# \=========================================================ooo==U==ooo=/ #
use strict;
use warnings;
use Encode;
use Data::Dumper;

use AnyEvent::Gearman;
use JSON::XS qw(decode_json encode_json);
use Net::Address::IP::Local;

use FindBin;
my ($RealBin_safe,$libdir);
BEGIN {
  $FindBin::RealBin =~ /^([^\0]+)\z/; # Valid Unix path TODO: Windows, revisit regexp
  $RealBin_safe = $1;
  die 'Fatal:IO:tainted RealBin was tainted! Failing...'
   unless ($RealBin_safe && (-e $RealBin_safe.'/cortex-worker')); 
  $libdir = $RealBin_safe."/../lib"; }

if (-d $libdir) {
  use lib $libdir;}

# Make sure we're terminating when requested to:
$SIG{'INT'} = \&stop_immediate; # Interrupt handler
$SIG{'HUP'} = \&stop_immediate; # Apache Hangup handler
$SIG{'KILL'} = \&stop_immediate; # Just good-old KILL handler
$SIG{'TERM'} = \&stop_immediate; # TERM handler
sub stop_immediate { exit 0; }
my $timeout_limit = 600; # If worker isn't done in 10 minutes - timeout

setpriority(0, $$, 20);

my ($s,@servers) = @ARGV;
my $identity = Net::Address::IP::Local->public;

# Restart support for keeping the worker operational over long inactivity periods
sub restart_worker {
  my ($reason) = @_;
  print STDERR "$reason reached, restarting worker $$ for $s\n";
  exec("$RealBin_safe/cortex-worker",$s,@servers)
    or die("Fatal:cortex-worker:restart Worker $$ autoflush Failed!"); }
# CorTeX workhorses have lowest priority, to avoid overloading the machine

my $worker = gearman_worker(@servers);
my $service;
my $eval_return = eval {require "CorTeX/Service/$s.pm"; 1; };
if ($eval_return && (!$@)) {
  $service = eval { "CorTeX::Service::$s"->new(); }; }
else {
  print STDERR "Service $s not available, exiting.\n$@\n";
  exit; }
my $job_limit = $service->job_limit();          
my $jobs = 0;
my ($job_timeout,$inactivity_timeout);
$worker->register_function(
  $s => sub {
    my $job = shift;
    undef $inactivity_timeout; # Reset inactivity timer, we're processing a job.
    $job_timeout = AnyEvent->timer(after => $timeout_limit, cb => sub { # Set job timer
      # When we timeout, fail this job and restart the worker
      $job->fail('Fatal:cortex-worker:timeout Worker timed out after $timeout_limit seconds.');
      restart_worker('Timeout');
    });   
    print STDERR "[".localtime()."] Job received by worker $$\n";
    my $response = $service->process($job->workload);
    $response //= {};
    if (ref($response) eq 'HASH') {
      $response->{log} //= "Fatal:Gearman:worker Processing failed silently";
      $response->{status} //= -4; # TODO: Fatal?
      $job->complete(encode_json($response)); }
    else {
      $job->complete($response); }
    print STDERR "[".localtime()."] Job completed by worker $$\n";
    if ($job_limit) {
      $jobs++;
      restart_worker('Job limit') if ($jobs > $job_limit); }
    undef $job_timeout; # Reset job timer
    # Restart after a minute of inactivity
    $inactivity_timeout = AnyEvent->timer(after => 60, cb => sub { 
      restart_worker('Inactivity Timeout'); });   
  }
);
print STDERR "Started Worker $$ for $s\n";

# Non-busy daemon
while(1) {
 my $loop_cv = AnyEvent->condvar;
 my $wait_daemon = AnyEvent->timer(after => 60, cb => sub { $loop_cv->send });
 $loop_cv->recv;
}